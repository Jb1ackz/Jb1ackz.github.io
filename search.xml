<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第一次文献汇报</title>
      <link href="/posts/f0a94950.html"/>
      <url>/posts/f0a94950.html</url>
      
        <content type="html"><![CDATA[<h1 id="ByteCard：基于学习的基数估计优化框架"><a href="#ByteCard：基于学习的基数估计优化框架" class="headerlink" title="ByteCard：基于学习的基数估计优化框架"></a>ByteCard：基于学习的基数估计优化框架</h1><h2 id="一、观感"><a href="#一、观感" class="headerlink" title="一、观感"></a>一、观感</h2><p>​        作为一个研0的新生 看完整篇文章 我认为我只能看懂百分之40，并且让我了解了我现在需要精进的技术栈—<strong>机器学习算法</strong>，他们包括线性回归、支持向量机、决策树、随机森林以及朴素贝叶斯等等，同时还需要扎实<strong>神经网络</strong>方面的知识。与此同时，<strong>数据库性能调优的研究方向</strong>也需要我了解更多数据库优化方面的知识，这篇文章作为一篇顶会文章，拓宽了我对于计算机领域研究的认识，在了解大佬的研究方法的同时，为自身明确学习的方向。</p><h2 id="二、文献解读"><a href="#二、文献解读" class="headerlink" title="二、文献解读"></a>二、文献解读</h2><h2 id="（1）首先看到题目ByteCard"><a href="#（1）首先看到题目ByteCard" class="headerlink" title="（1）首先看到题目ByteCard"></a>（1）首先看到题目ByteCard</h2><p>​        该框架实现了一个<strong>学习型的基数估计的优化</strong>，这里也是我第一次接触到基数估计的概念，基数估计是计算机中某个查询需要统计出某列数据的NDV(Number of Distinct Values),而且场景多为大型数据，数据多到无法全部加载入内存，这时我们想要对基数（数据集合中不同元素的个数）进行估计，传统的基数估计则为查询优化器中Selinger型基数估计器负责，会产出大量的估计错误，导致次优查询计划</p><h2 id="2-ByteCard的优点"><a href="#2-ByteCard的优点" class="headerlink" title="(2) ByteCard的优点"></a>(2) ByteCard的优点</h2><p>​        在提高基数估计的准确性的同时，保持实际的推理开销，有效地训练和集成学习的基数估计器。文章中用实验数据表明ByteCard的集成导致延迟的第99分位数改善高达30%，效果显著。 在这里补充Selinger型估计器缺点：实际数据中属性往往存在关联，但 Selinger 型估计器假设它们独立，会导致估计偏差，导致其在复杂场景下的估计不够精准，而这成为了ByteHouse数据仓库的巨大瓶颈。</p><h2 id="（3）传统基数估计方法（CardEst）在-ByteHouse-中的估计误差表格"><a href="#（3）传统基数估计方法（CardEst）在-ByteHouse-中的估计误差表格" class="headerlink" title="（3）传统基数估计方法（CardEst）在 ByteHouse 中的估计误差表格"></a>（3）传统基数估计方法（CardEst）在 ByteHouse 中的估计误差表格</h2><table><thead><tr><th>估计类型</th><th>数据集</th><th>50% 分位数</th><th>90% 分位数</th><th>99% 分位数</th></tr></thead><tbody><tr><td><strong>COUNT Est.</strong></td><td>IMDB</td><td>3.06</td><td>1145</td><td>1×10⁶</td></tr><tr><td></td><td>STATS</td><td>493</td><td>3×10⁴</td><td>3×10⁷</td></tr><tr><td></td><td>AEOLUS</td><td>7.45</td><td>3×10⁶</td><td>8×10⁶</td></tr><tr><td><strong>NDV Est.</strong></td><td>IMDB</td><td>15</td><td>984</td><td>3×10⁴</td></tr><tr><td></td><td>STATS</td><td>134</td><td>1×10⁴</td><td>6×10⁴</td></tr><tr><td></td><td>AEOLUS</td><td>598</td><td>4912</td><td>2×10⁴</td></tr></tbody></table><p>​        该表格展示了传统基数估计方法（CardEst）在 ByteHouse 中对三类典型数据集（IMDB、STATS、AEOLUS）进行基数估计时的误差分布，重点通过<strong>分位数</strong>（50%、90%、99%）反映不同比例查询的误差大小。对该表格进行分析得出以下结论</p><ol><li><p><strong>误差的整体特征：分位数越高，误差越大</strong></p></li><li><p><strong>COUNT Est. vs NDV Est.：行数估计误差更极端</strong></p></li><li><p><strong>数据集差异：STATS 和 AEOLUS 的误差更显著</strong></p></li></ol><p>​         揭示了传统基数估计方法（CardEst）的核心问题：<strong>在数据偏斜或复杂场景中，估计误差会随查询极端程度（分位数）急剧放大，且行数估计（COUNT）比不同值估计（NDV）更敏感</strong>。这也解释了为何现代数据库（如 ByteHouse）需要改进基数估计方法（如引入高频值统计、机器学习模型）—— 以缓解传统方法在极端场景下的误差，提升查询优化的稳定性。</p><h2 id="（4）提问：我们能否用基于学习的方法取代ByteHouse中的传统方法？"><a href="#（4）提问：我们能否用基于学习的方法取代ByteHouse中的传统方法？" class="headerlink" title="（4）提问：我们能否用基于学习的方法取代ByteHouse中的传统方法？"></a>（4）提问：我们能否用基于学习的方法取代ByteHouse中的传统方法？</h2><p>​        文中指出了三个挑战：</p><ol><li><p>如何识别适当的估计模型，平衡准确性和实用性 </p></li><li><p>如何管理训练过程，并在查询处理中集成这些模型的推理算法</p></li><li><p>如何利用模型的估计来实现ByteHouse的增强查询优化</p></li></ol><p>​        文章在讲解他们的研究和设计过程时提出了大量的算法和模型，由于能力有限我没法一一了解，这需要很大量的时间，这里只关注文章的重点，分析最终的实现方法。这里提一下ByteHouse的架构。ByteHouse采用存储与计算分离的架构，由三个独立的层组成：服务，计算和存储。</p><p><img src="https://youke1.picui.cn/s1/2025/07/21/687ded56527e8.png" alt="The Architecture of ByteHouse"></p><p>​         其流程为：用户查询经 Query Gateway 进入，Parser 解析、Query Analyzer and Optimizer 优化，Plan Scheduler 调度到计算层虚拟仓库执行；数据从存储层读取，计算中用 Cache 加速，结果返回用户；后台任务（如数据导入、Merge Out）由 Daemon Manager 等组件协同管理。</p><h2 id="（5）ByteCard的架构"><a href="#（5）ByteCard的架构" class="headerlink" title="（5）ByteCard的架构"></a>（5）ByteCard的架构</h2><p><img src="https://youke1.picui.cn/s1/2025/07/21/687dfec16ad9c.png" alt="The Architecture of ByteCard"></p><p>​        文章的四、五两章是关于ByteCard架构的讲解，也是全文的核心部分，对ByteCard的各个模块进行了详细的描述，给出了作者在不同优化场景中选择不同算法的理由。ByteCard引入了两个核心模块，即：一个被称为推理引擎的高级程序抽象和一个名为ModelForge Service的独立服务，以及辅助模块，以保持ByteCard的效率和有效性，同时保障ByteHouse的稳定性。</p><p>ByteCard 架构图主要展示其核心组件及与上下游系统（如数据源、ByteHouse）的交互逻辑，可从<strong>组件功能</strong>、<strong>数据流转</strong>、<strong>核心能力</strong>三方面拆解：</p><h4 id="一、核心组件与功能"><a href="#一、核心组件与功能" class="headerlink" title="一、核心组件与功能"></a>一、核心组件与功能</h4><ol><li><p><strong>ByteCard 模块</strong></p><ul><li><p>ModelForge Service</p><p>：</p><ul><li><code>Sample</code>（采样）：从上游数据源 &#x2F; ByteHouse 抽取数据样本，为模型训练准备基础数据；</li><li><code>Train</code>（训练）：基于采样数据训练 cardinality（基数）、NDV（不同值数量）等估计模型，是 “学习型估计” 的核心；</li><li><code>Model Monitor</code>（模型监控）：跟踪模型训练、推理的状态（如精度、性能），保障模型可靠性。</li></ul></li><li><p>Model Loader&#x2F;Validator</p><p>（模型加载 &#x2F; 校验）：</p><ul><li>从<code>Cloud Shared Models Storage</code>加载预训练模型，校验其可用性、精度，确保推理质量。</li></ul></li><li><p>Inference Engine</p><p>（推理引擎）：</p><ul><li>细分<code>Multi-Column</code>（多列）、<code>Multi-Table</code>（多表）、<code>NDV</code>（不同值数量）场景，提供 cardinality estimate（基数估计）能力，直接为 ByteHouse 的查询优化提供基础。</li></ul></li></ul></li><li><p><strong>上下游关联系统</strong></p><ul><li><p><strong>Upstream Data Source</strong>（上游数据源）：为 ByteCard 提供原始数据，支撑模型训练的数据采样。</p></li><li><p><strong>Cloud Shared Models Storage</strong>（模型共享存储）：存储训练好的模型，实现模型的持久化、复用，支持跨环境加载。</p></li><li><p>ByteHouse</p><p>（下游数仓）：</p><ul><li><code>Data Ingestor</code>（数据摄入）：接收 ByteCard 的通知（如模型更新后的数据修正），保障数仓数据与模型协同；</li><li><code>Daemon Manager</code>（守护进程管理）：调度 ByteCard 的模型加载、推理任务，串联数仓查询流程；</li><li><code>Query Analyzer and Optimizer</code>（查询分析与优化器）：结合 ByteCard 的 cardinality estimate，优化查询计划；</li><li><code>Model Preprocessor</code>（模型预处理）：为查询优化器准备模型输入，<code>Virtual Warehouses</code>（虚拟仓库）提供计算资源。</li></ul></li></ul></li></ol><h4 id="二、数据与流程流转"><a href="#二、数据与流程流转" class="headerlink" title="二、数据与流程流转"></a>二、数据与流程流转</h4><ol><li><strong>模型训练流程</strong>：<br>上游数据源 → ByteCard <code>Sample</code> 采样 → <code>ModelForge Service</code> <code>Train</code> 训练模型 → 模型存入 <code>Cloud Shared Models Storage</code> → 经 <code>Model Validator</code> 校验后，由 <code>Model Loader</code> 加载至推理引擎。</li><li><strong>查询优化流程</strong>：<br>ByteHouse 发起查询 → <code>Query Analyzer</code> 调用 ByteCard <code>Inference Engine</code>（多列 &#x2F; 多表 &#x2F; NDV 场景） → 输出 cardinality estimate → 辅助 <code>Optimizer</code> 生成最优查询计划 → 基于 <code>Virtual Warehouses</code> 执行查询。</li><li><strong>闭环管理</strong>：<br><code>Model Monitor</code> 监控模型全生命周期（训练、推理），发现精度下降或异常时，触发 <code>ModelForge Service</code> 重新采样、训练，形成 “数据 - 训练 - 监控 - 迭代” 闭环。</li></ol><h4 id="三、架构设计的核心目标"><a href="#三、架构设计的核心目标" class="headerlink" title="三、架构设计的核心目标"></a>三、架构设计的核心目标</h4><ol><li><strong>“学习型” 基数估计</strong>：<br>区别于传统基于统计的基数估计，ByteCard 通过 <code>ModelForge Service</code> 实现模型训练，让基数估计适配复杂数据分布（如多表关联、高基数列），提升数仓查询优化的准确性。</li><li><strong>与 ByteHouse 深度协同</strong>：<br>从数据摄入（<code>Data Ingestor</code> 接收通知）到查询优化（<code>Query Analyzer</code> 依赖 cardinality estimate），ByteCard 嵌入 ByteHouse 数仓流程，解决 “查询计划不准确导致的性能问题”，是云原生数仓的优化增强组件。</li><li><strong>工程化落地保障</strong>：<br><code>Model Monitor</code> 保障模型可靠性，<code>Cloud Shared Models Storage</code> 实现模型复用，<code>Inference Engine</code> 细分场景适配数仓查询需求，让 “学习型估计” 从算法落地到生产系统。</li></ol><p>简单说，ByteCard 是为 ByteHouse 数仓设计的<strong>学习型基数估计引擎</strong>，通过模型训练、推理与数仓流程深度整合，解决传统基数估计的精度问题，最终目标是让数仓查询更快、更稳定。</p><p>此次的文献阅读就到这里，这次的阅读让我更加了解数据库性能优化这个方向（特别是基数估计的优化），之后我需要提升机器学习、深度学习和神经网络的知识，在有了ai知识的基础后再重新读一遍这篇文章，而且要读其他优化场景的文章，任务还是比较多的，感谢大家的观看，让我们一起在计算机研究上成长和进步。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 文献阅读 数据库性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch环境配置</title>
      <link href="/posts/5864f7c5.html"/>
      <url>/posts/5864f7c5.html</url>
      
        <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>距离考研复试还有8天的时间，复试准备的差不多了。倒腾一下AI的学习，之前看过窦导发来的论文，有关<strong>GPTuner：通过 GPT 引导的贝叶斯优化的手动读取数据库调优系统</strong> 看完发现自己缺乏AI方面的知识（本科都在打ctf竞赛和准备考研）看了一些AI的课程，推荐一下b站吴承恩的机器学习 有时间的话可以好好研究一下 <u><a href="https://www.bilibili.com/video/BV164411b7dx?vd_source=b29e9f5ab7ad609b65f2c55471e93d34&spm_id_from=333.788.videopod.episodes">吴恩达机器学习系列课程</a></u></p><h2 id="pytorch环境配置"><a href="#pytorch环境配置" class="headerlink" title="pytorch环境配置"></a>pytorch环境配置</h2><p>pytorch是学习模型训练的初级工具，配置好之后可以学习如何训练模型，可以说配置完了就算半只脚踏进ai学习领域了</p><ol><li><p>下载安装anaconda <u><a href="www.anaconda.com">anaconda官网</a></u>  安装完成后打开anaconda prompt 左边会显示 (base) 即为成功</p></li><li><p>安装pytorch之前 <strong>创建一个pytorch的虚拟环境 并且指定其python版本</strong>（没有下python的话 还要先配置python 我一开始看教程下的低版本[3.6]，低版本后面安装cuda 和cudnn的时候有问题，我又根据报错提示改成3.10版本的）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pytorch python=<span class="number">3</span>.<span class="number">10</span></span><br><span class="line">#创建成功后 可以activate进入</span><br><span class="line">conda activate pytorch</span><br><span class="line">#deactivate退出</span><br><span class="line">conda deactivate</span><br><span class="line">#查看环境中都有什么</span><br><span class="line">pip list</span><br></pre></td></tr></table></figure></li><li><p>安装pytorch需要看cuda的版本以及python的版本 三者要对应</p><p>具体可以看这篇博客 <u><a href="https://blog.csdn.net/u011489887/article/details/135250561">pytorch cuda python 版本对应</a></u> </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#我的版本</span><br><span class="line"><span class="function">python: 3.10</span></span><br><span class="line"><span class="function"><span class="title">cuda</span>: 12.1</span></span><br><span class="line"><span class="function"><span class="title">cudnn</span>:9.8.0</span></span><br><span class="line"><span class="function"><span class="title">pytorch</span>:2.1.0</span></span><br></pre></td></tr></table></figure><p>然后关于cuda的安装 我这里只适用i卡 a卡或者集显自己去看看其他博客</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看自己cuda的版本 有一个CUDA Version 意思是向下兼容 <span class="number">12</span>.<span class="number">5</span>的话小于等于<span class="number">12</span>.<span class="number">5</span>的cuda都可以装</span><br><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><p>知道版本后开始安装</p><p>首先是 <strong>cuda安装地址</strong> <u><a href="https://developer.nvidia.com/cuda-12-1-0-download-archive?target_os=Windows&target_arch=x86_64&target_version=11&target_type=exe_local">CUDA Toolkit 12.1 Downloads | NVIDIA Developer</a></u> </p><p>然后 安装cudnn <u><a href="https://developer.nvidia.com/cudnn-downloads?target_os=Windows&target_arch=x86_64&target_version=Agnostic&cuda_version=12">cuDNN 9.8.0 Downloads | NVIDIA Developer</a></u></p><p>最后安装pytorch  <u><a href="https://pytorch.org/get-started/previous-versions/">安装命令</a></u> </p><p>pytorch的安装需要换源 如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># -c pytorch 是国外源 会从官网下载 很慢</span><br><span class="line">conda install pytorch==<span class="number">2</span>.<span class="number">1</span>.<span class="number">1</span> torchvision==<span class="number">0</span>.<span class="number">16</span>.<span class="number">1</span> torchaudio==<span class="number">2</span>.<span class="number">1</span>.<span class="number">1</span> pytorch-cuda=<span class="number">12</span>.<span class="number">1</span> -c pytorch -c nvidia</span><br><span class="line"></span><br><span class="line">#配置清华源 <span class="number">4</span>条命令 执行完后c盘用户名文件夹下会有 .condrc</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line"></span><br><span class="line">conda config --add channels </span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">https://<span class="title">mirrors.tuna.tsinghua.edu.cn</span>/<span class="title">anaconda</span>/<span class="title">pkgs</span>/<span class="title">main</span>/</span></span><br><span class="line"><span class="function"><span class="title">conda</span> <span class="title">config</span> --<span class="title">set</span> <span class="title">show_channel_urls</span> <span class="title">yes</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">conda</span> <span class="title">config</span> --<span class="title">add</span> <span class="title">channels</span> <span class="title">https</span>://<span class="title">mirrors.tuna.tsinghua.edu.cn</span>/<span class="title">anaconda</span>/<span class="title">cloud</span>/<span class="title">pytorch</span>/</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"># 配置清华源再去掉 -<span class="title">c</span> <span class="title">pytorch</span>下载</span></span><br><span class="line"><span class="function"><span class="title">conda</span> <span class="title">install</span> <span class="title">pytorch</span>==2.1.1 <span class="title">torchvision</span>==0.16.1 <span class="title">torchaudio</span>==2.1.1 <span class="title">pytorch</span>-<span class="title">cuda</span>=12.1  -<span class="title">c</span> <span class="title">nvidia</span></span></span><br></pre></td></tr></table></figure></li><li><p>检查安装是否成功</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#先看一下</span><br><span class="line">pip list</span><br></pre></td></tr></table></figure><p>利用python试一下能不能导入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入pytorch虚拟环境 (pytorch)</span></span><br><span class="line">python</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment">#看看终端的输出是不是true</span></span><br><span class="line">torch.cuda.is_available()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>到这里就完成torch的整个环境安装了，要注解各个环境的版本，最容易出错的就是版本不对，然后要重装</p><p>安装完pytorch再配置一下编辑器（pycharm和jupyter）就可以开始学习训练ai模型了</p></li></ol><h4 id="目前学了Dataset类，了解了模型训练的过程"><a href="#目前学了Dataset类，了解了模型训练的过程" class="headerlink" title="目前学了Dataset类，了解了模型训练的过程"></a>目前学了Dataset类，了解了模型训练的过程</h4><p>​ 比如我利用蜜蜂和蚂蚁的图片信息训练模型，通过这些图片作为训练集输入，模型在后期可以分辨出图片中哪些是蚂蚁哪些是蜜蜂。或者像机器学习课程说的那样 可以分辨出垃圾邮件。这篇文章作为我ai学习的开端，希望可以帮助各位配置自己的pytorch环境。共勉！</p>]]></content>
      
      
      
        <tags>
            
            <tag> AI模型训练 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"jb1ack's Blog","short_name":"Jb1ack","theme_color":"#3b70fc","background_color":"#3b70fc","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
  
</search>
